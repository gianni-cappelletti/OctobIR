#pragma once

#include <memory>
#include <string>
#include <vector>

#include "AudioBuffer.hpp"
#include "IRLoader.hpp"
#include "Types.hpp"

class WDL_ImpulseBuffer;
class WDL_ConvolutionEngine_Div;

namespace octob
{

class IRProcessor
{
 public:
  IRProcessor();
  ~IRProcessor();

  bool loadImpulseResponse(const std::string& filepath, std::string& errorMessage);
  bool loadImpulseResponse2(const std::string& filepath, std::string& errorMessage);

  void setSampleRate(SampleRate sampleRate);
  void setBlend(float blend);

  void setIRAEnabled(bool enabled);
  void setIRBEnabled(bool enabled);
  void setDynamicModeEnabled(bool enabled);
  void setSidechainEnabled(bool enabled);
  void setLowBlend(float lowBlend);
  void setHighBlend(float highBlend);
  void setThreshold(float thresholdDb);
  void setRangeDb(float rangeDb);
  void setKneeWidthDb(float kneeDb);
  void setDetectionMode(int mode);
  void setAttackTime(float attackTimeMs);
  void setReleaseTime(float releaseTimeMs);
  void setOutputGain(float gainDb);

  void processMono(const Sample* input, Sample* output, FrameCount numFrames);
  void processStereo(const Sample* inputL, const Sample* inputR, Sample* outputL, Sample* outputR,
                     FrameCount numFrames);
  void processDualMono(const Sample* inputL, const Sample* inputR, Sample* outputL, Sample* outputR,
                       FrameCount numFrames);

  void processMonoWithSidechain(const Sample* input, const Sample* sidechain, Sample* output,
                                FrameCount numFrames);
  void processStereoWithSidechain(const Sample* inputL, const Sample* inputR,
                                  const Sample* sidechainL, const Sample* sidechainR,
                                  Sample* outputL, Sample* outputR, FrameCount numFrames);
  void processDualMonoWithSidechain(const Sample* inputL, const Sample* inputR,
                                    const Sample* sidechainL, const Sample* sidechainR,
                                    Sample* outputL, Sample* outputR, FrameCount numFrames);

  bool isIRLoaded() const { return irLoaded_; }
  bool isIR2Loaded() const { return ir2Loaded_; }
  std::string getCurrentIRPath() const { return currentIRPath_; }
  std::string getCurrentIR2Path() const { return currentIR2Path_; }
  SampleRate getIRSampleRate() const;
  SampleRate getIR2SampleRate() const;
  size_t getIRNumSamples() const;
  size_t getIR2NumSamples() const;
  int getNumIRChannels() const;
  int getNumIR2Channels() const;
  int getLatencySamples() const;
  float getBlend() const { return blend_; }

  bool getIRAEnabled() const { return irAEnabled_; }
  bool getIRBEnabled() const { return irBEnabled_; }
  bool getDynamicModeEnabled() const { return dynamicModeEnabled_; }
  bool getSidechainEnabled() const { return sidechainEnabled_; }
  float getLowBlend() const { return lowBlend_; }
  float getHighBlend() const { return highBlend_; }
  float getThreshold() const { return thresholdDb_; }
  float getRangeDb() const { return rangeDb_; }
  float getKneeWidthDb() const { return kneeWidthDb_; }
  int getDetectionMode() const { return detectionMode_; }
  float getAttackTime() const { return attackTimeMs_; }
  float getReleaseTime() const { return releaseTimeMs_; }
  float getOutputGain() const { return outputGainDb_; }
  float getCurrentInputLevel() const { return currentInputLevelDb_; }
  float getCurrentBlend() const { return currentBlend_; }

  void reset();

 private:
  std::unique_ptr<WDL_ImpulseBuffer> impulseBuffer_;
  std::unique_ptr<WDL_ConvolutionEngine_Div> convolutionEngine_;
  std::unique_ptr<IRLoader> irLoader_;

  std::unique_ptr<WDL_ImpulseBuffer> impulseBuffer2_;
  std::unique_ptr<WDL_ConvolutionEngine_Div> convolutionEngine2_;
  std::unique_ptr<IRLoader> irLoader2_;

  SampleRate sampleRate_ = 44100.0;
  std::string currentIRPath_;
  std::string currentIR2Path_;
  bool irLoaded_ = false;
  bool ir2Loaded_ = false;
  int latencySamples_ = 0;
  int latencySamples2_ = 0;
  float blend_ = 0.0f;

  bool irAEnabled_ = true;
  bool irBEnabled_ = true;
  bool dynamicModeEnabled_ = false;
  bool sidechainEnabled_ = false;
  float lowBlend_ = -1.0f;
  float highBlend_ = 1.0f;
  float thresholdDb_ = -30.0f;
  float rangeDb_ = 20.0f;
  float kneeWidthDb_ = 5.0f;
  int detectionMode_ = 0;
  std::vector<float> rmsBuffer_;
  size_t rmsBufferIndex_ = 0;
  size_t rmsBufferSize_ = 0;
  static constexpr float kRMSWindowMs_ = 10.0f;
  float attackTimeMs_ = 50.0f;
  float releaseTimeMs_ = 200.0f;
  float outputGainDb_ = 0.0f;

  float currentInputLevelDb_ = -96.0f;
  float currentBlend_ = 0.0f;
  float smoothedBlend_ = 0.0f;
  float outputGainLinear_ = 1.0f;
  float attackCoeff_ = 0.0f;
  float releaseCoeff_ = 0.0f;

  float calculateDynamicBlend(float inputLevelDb) const;
  static float detectPeakLevel(const Sample* buffer, FrameCount numFrames);
  float detectRMSLevel(const Sample* buffer, FrameCount numFrames);
  void updateSmoothingCoefficients();
  void updateRMSBufferSize();
  void applyOutputGain(Sample* buffer, FrameCount numFrames) const;
};

}  // namespace octob
